---
layout: post
---

### What are languages?

Before we delve into programming languages, first lets talk about what are languages in the first place? It's easy to speak it, but we often speak it without understanding the nuance of how it all works. It's second nature to us, but can we actually write down the rules that generate what's right and wrong sentences in our language?

Some defintions are required here:
* A language is a set of strings over a finite alphabet. (In english, this sentence is a set of strings. Our alphabet consists of 26 characters.)
* A generator is a set of rules to create strings.
* A recognizer takes an input of strings and determines if it's part of the language. ("this is true" is part of English. "true this is" is part of Yoda speak. Recognizers use grammars to verify, more on this later)
* Syntax is the form/structure. (EX: ----)
* Semantics is the meaning.

Languages are characterized by the complexity of their generator and recognizer. There is a heirarchy defined by Chomsky (A famous linguist) called (very fittingly) the Chomsky Hierarchy. (Btw, chomsky sounds like it would be a very good name for a pet cat).

[picture of heirarchy]

The 2 lowest forms are also the 2 important forms for programming languages: regular language and context free language.

In programming languages,
Regular languages
* Describes tokens.
* generates through regular expression
* recognizes through a [finite automata]() (scanner)

while Context free languages
* Descibes the more complex constructs
* generates through context free grammar
* recognizes through a [push down automata]() (parser)

### What are Regular Expressions?

If your a programmer, you've probably delt with regex in some form either through class or using a tool like grep.

Regex is composed of 6 things:
* a character
* an empty string (epsilon)
* concatenation. given regex R1 and R2: R1R2 (R1 followed by R2)
* alternation. given regex R1 and R2: R1\|R2 (R1 or R2)
* kleene star (*). means one or more of a type.

The precedence follows this order:
Kleene, concat, alternation.

Regex is pretty simple, so it's used to describe tokens. But it lacks one critical thing to be able to describe more
complex constructs, and that's recursion. This is where grammar comes in.

### What are Grammars?

A grammar is a formalism to describe the strings of a language.
It consists of
* terminals: characters
* non-terminals: language constructs
* productions: the rules
* start symbol

There are multiple types of grammars.

Regular grammar generate regular languages (duh).
There rules consist of:
* Each lhs has exactly one non-terminal
* Each rhs has
    * a single terminal
    * a single non-terminal or
    * a non-terminal followed by a terminal

Context free grammar generate context free languages (also, very duh).
These rules consist of:
* Each lhs has exactly one non-terminal
* Each rhs has an arbitrary sequence of terminals and non-terminals.
So, it's a lot more free than regular grammar in terms of the rhs.
THIS is the reason why we call it "context free". It's rules are applied without any 
ordering of the symbols. So it is free of the contexts of surrounding symbols.

Expression grammar generates expressions (----)

The steps of expanding a sequence based on its grammar is called the derivation, the setential form is the intermediate sentence, and the result is called the yield. Just some formal definitions for you.

The derivation starts with the start symbol, and left-most derivation means to expand the non-terminals left-to-right, while right-most derivation means to expand the non-terminals right-to-left.

And this derivation, when visually shown, creates something called a parse tree.

### Ambiguity

A grammar is considered ambigious if some string can be generated by two or more parse trees. Ambiguitity is bad, because it's confusing and in programming languages ----.

So how do we resolve ambiguity?
We can define a layer of precedence, and rewrite the grammar through more intermediate terms to resolve ambiguity.